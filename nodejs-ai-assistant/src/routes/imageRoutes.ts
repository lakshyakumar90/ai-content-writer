import express from "express";
import type { Request, Response } from "express";
import { requireAuth, AuthedRequest } from "../auth";
import { GoogleGenAI } from "@google/genai";
import mime from "mime";
import { ImageGenerationModel } from "../models/ImageGeneration";
import { initCloudinary, uploadImageToCloudinary } from "../services/cloudinary";

const router = express.Router();

// Ensure Cloudinary is configured on first import
try {
  initCloudinary();
} catch (e) {
  // Defer throwing to route level so server can still boot for non-image routes
  console.warn("Cloudinary not configured yet. Image routes will fail until set.");
}

// POST /images/generate
router.post("/generate", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const { prompt, size = 512 } = req.body || {};
    if (!prompt) {
      return res.status(400).json({ error: "prompt is required" });
    }

    const ai = new GoogleGenAI({
      apiKey: process.env.GEMINI_API_KEY!,
    });

    const config = {
      responseModalities: ["IMAGE", "TEXT"],
      imageConfig: { imageSize: size >= 1024 ? "2K" : size >= 768 ? "1.5K" : "1K" },
    } as any;

    const model = "gemini-2.5-flash-image";
    const contents = [
      {
        role: "user",
        parts: [{ text: prompt }],
      },
    ];

    // Stream response and capture first inline image
    const response = await ai.models.generateContentStream({
      model,
      config,
      contents,
    });

    let uploadedUrl: string | null = null;
    // stream yields chunks containing inlineData images or text
    for await (const chunk of response) {
      if (!chunk.candidates || !chunk.candidates[0].content?.parts) continue;
      const part = chunk.candidates[0].content.parts[0] as any;
      if (part?.inlineData && !uploadedUrl) {
        const inlineData = part.inlineData;
        const fileExtension = mime.getExtension(inlineData.mimeType || "png") || "png";
        const buffer = Buffer.from(inlineData.data || "", "base64");
        // Upload the generated image buffer to Cloudinary
        uploadedUrl = await uploadImageToCloudinary(buffer);
        break; // stop after first image
      }
    }

    if (!uploadedUrl) {
      throw new Error("No image generated by Gemini");
    }

    const doc = await ImageGenerationModel.create({
      userId: req.userId,
      prompt,
      imageUrl: uploadedUrl,
      sourceUrl: undefined,
      model: "google/gemini-2.5-flash-image",
      size,
      status: "completed",
    });

    res.json({
      _id: doc._id.toString(),
      prompt: doc.prompt,
      imageUrl: doc.imageUrl,
      sourceUrl: doc.sourceUrl,
      model: doc.model,
      size: doc.size,
      createdAt: doc.createdAt,
    });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error("Image generation error:", errorMessage);
    res.status(500).json({ error: "Failed to generate image", details: errorMessage });
  }
});

// GET /images/history?page=&limit=
router.get("/history", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const page = Math.max(parseInt(String(req.query.page || "1"), 10) || 1, 1);
    const limit = Math.min(Math.max(parseInt(String(req.query.limit || "20"), 10) || 20, 1), 100);
    const skip = (page - 1) * limit;

    const [items, total] = await Promise.all([
      ImageGenerationModel.find({ userId: req.userId })
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .lean(),
      ImageGenerationModel.countDocuments({ userId: req.userId }),
    ]);

    const hasMore = skip + items.length < total;
    res.json({ items, page, limit, total, hasMore });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    res.status(500).json({ error: "Failed to fetch history", details: errorMessage });
  }
});

// GET /images/:id
router.get("/:id", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const item = await ImageGenerationModel.findOne({ _id: id, userId: req.userId }).lean();
    if (!item) {
      return res.status(404).json({ error: "Not found" });
    }
    res.json(item);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    res.status(500).json({ error: "Failed to fetch item", details: errorMessage });
  }
});

// DELETE /images/:id (optional)
router.delete("/:id", requireAuth, async (req: AuthedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const item = await ImageGenerationModel.findOneAndDelete({ _id: id, userId: req.userId });
    if (!item) {
      return res.status(404).json({ error: "Not found" });
    }
    // Optionally: also delete from Cloudinary via public_id if we stored it
    res.json({ ok: true });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    res.status(500).json({ error: "Failed to delete item", details: errorMessage });
  }
});

export default router;


